name: Reusable - Deploy Terraform

on:
  workflow_call:
    inputs:
      service-path:
        required: true
        type: string
      environment:
        required: true
        type: string
      stack:
        required: true
        type: string
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write # Required for OIDC authentication with AWS

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-3 # Should match your common.tfvars

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Download and Unpack Deployment Package
        run: |
          # Define package names for both the specific stack (e.g., pr123) and the fallback (rc)
          STACK_PACKAGE_NAME="${{ inputs.service-path }}-${{ inputs.stack }}.zip"
          RC_PACKAGE_NAME="${{ inputs.service-path }}-rc.zip"

          S3_BUCKET="sally-package-registry"
          STACK_S3_KEY="packages/${STACK_PACKAGE_NAME}"
          RC_S3_KEY="packages/${RC_PACKAGE_NAME}"

          echo "Attempting to download package: ${STACK_PACKAGE_NAME}"
          # Try to download the stack-specific package. If it fails (||), try to download the rc package.
          # The `aws s3 cp` command will exit with a non-zero status if the file is not found.
          (aws s3 cp "s3://${S3_BUCKET}/${STACK_S3_KEY}" "${STACK_PACKAGE_NAME}" && echo "Downloaded ${STACK_PACKAGE_NAME}") || \
          (aws s3 cp "s3://${S3_BUCKET}/${RC_S3_KEY}" "${RC_PACKAGE_NAME}" && echo "Downloaded fallback ${RC_PACKAGE_NAME}")

          # Unzip whichever package was successfully downloaded
          PACKAGE_TO_UNZIP=$(ls *.zip | head -n 1)
          echo "Unpacking artifact: ${PACKAGE_TO_UNZIP}"
          unzip -o "${PACKAGE_TO_UNZIP}" -d .
          # The package contains a 'terraform' directory, so we can now work with it.

      - name: Terraform Init
        run: |
          if [ "${{ inputs.environment }}" != "global" ]; then
            terraform init \
              -backend-config="bucket=sally-terraform-state-bucket" \
              -backend-config="key=${{ inputs.stack }}/${{ inputs.service-path }}/terraform.tfstate" \
              -backend-config="region=eu-west-3"
          else
            terraform init
          fi
        working-directory: ./terraform

      - name: Terraform Plan
        run: |
          cp environments/common.tfvars .
          TF_VARS="-var-file=common.tfvars"
          if [ "${{ inputs.environment }}" != "global" ]; then
            cp environments/${{ inputs.environment }}.tfvars .
            TF_VARS="$TF_VARS -var-file=${{ inputs.environment }}.tfvars"
          fi
          terraform plan -no-color -var="stack=${{ inputs.stack }}" ${TF_VARS}
        working-directory: ./terraform

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main' || github.event_name == 'pull_request'
        run: |
          cp environments/common.tfvars .
          TF_VARS="-var-file=common.tfvars"
          if [ "${{ inputs.environment }}" != "global" ]; then
            cp environments/${{ inputs.environment }}.tfvars .
            TF_VARS="$TF_VARS -var-file=${{ inputs.environment }}.tfvars"
          fi
          terraform apply -auto-approve -no-color -var="stack=${{ inputs.stack }}" ${TF_VARS}
        working-directory: ./terraform