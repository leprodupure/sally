name: Reusable - Deploy Terraform

on:
  workflow_call:
    inputs:
      action:
        required: false
        type: string
        default: 'apply'
      service-path:
        required: true
        type: string
      environment:
        required: true
        type: string
      stack:
        required: true
        type: string
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true

jobs:
  terraform:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write # Required for OIDC authentication with AWS

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-3 # Should match your common.tfvars

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Download and Unpack Deployment Package
        if: inputs.action == 'apply' && inputs.environment != 'global'
        run: |
          SERVICE_NAME=$(basename "${{ inputs.service-path }}")
          STACK_PACKAGE_NAME="${SERVICE_NAME}-package.zip"
          RC_PACKAGE_NAME="${SERVICE_NAME}-package.zip"
          S3_BUCKET="sally-package-registry"
          STACK_S3_KEY="packages/${SERVICE_NAME}-${{ inputs.stack }}.zip"
          RC_S3_KEY="packages/${SERVICE_NAME}-rc.zip"

          echo "Attempting to download package: ${STACK_S3_KEY}"
          (aws s3 cp "s3://${S3_BUCKET}/${STACK_S3_KEY}" "${STACK_PACKAGE_NAME}" && echo "Downloaded ${STACK_PACKAGE_NAME}") || \
          (aws s3 cp "s3://${S3_BUCKET}/${RC_S3_KEY}" "${RC_PACKAGE_NAME}" && echo "Downloaded fallback ${RC_PACKAGE_NAME}")

          PACKAGE_TO_UNZIP=$(ls *-package.zip | head -n 1)
          echo "Unpacking artifact: ${PACKAGE_TO_UNZIP}"
          unzip -o "${PACKAGE_TO_UNZIP}" -d .

      - name: Run Database Migrations via Lambda (if applicable)
        if: inputs.action == 'apply' && inputs.environment != 'global' && hashFiles('alembic.ini') != ''
        run: |
          echo "--- Found alembic.ini, invoking migration runner Lambda... ---"
          SERVICE_NAME=$(basename "${{ inputs.service-path }}")
          S3_BUCKET="sally-package-registry"
          PR_S3_KEY="packages/${SERVICE_NAME}-${{ inputs.stack }}.zip"
          RC_S3_KEY="packages/${SERVICE_NAME}-rc.zip"
          S3_KEY_TO_USE=""
          FUNCTION_NAME="sally-${{ inputs.stack }}-migration-runner"

          echo "Checking for PR-specific package: s3://${S3_BUCKET}/${PR_S3_KEY}"
          if aws s3api head-object --bucket "${S3_BUCKET}" --key "${PR_S3_KEY}" >/dev/null 2>&1; then
            echo "PR-specific package found. Using ${PR_S3_KEY}"
            S3_KEY_TO_USE="${PR_S3_KEY}"
          else
            echo "PR-specific package not found. Falling back to RC package: ${RC_S3_KEY}"
            S3_KEY_TO_USE="${RC_S3_KEY}"
          fi

          echo "Invoking Lambda with payload: {s3_key: ${S3_KEY_TO_USE}}"
          PAYLOAD=$(jq -n --arg key "$S3_KEY_TO_USE" '{s3_key: $key}')

          aws lambda invoke \
            --invocation-type RequestResponse \
            --function-name "$FUNCTION_NAME" \
            --payload "$PAYLOAD" \
            --cli-binary-format raw-in-base64-out \
            --log-type Tail \
            output.json
          
          STATUS=$(jq -r '.status' output.json)
          
          if [ "$STATUS" != "SUCCESS" ]; then
            echo "::error::Lambda migration failed!"
            jq '.' output.json
            exit 1
          fi
          echo "Lambda migration successful."

      - name: Terraform Apply (Services)
        if: inputs.action == 'apply' && inputs.environment != 'global'
        working-directory: terraform
        run: |
          echo "--- Initializing Terraform for Service Apply ---"
          terraform init \
            -backend-config="bucket=sally-terraform-state-bucket" \
            -backend-config="key=${{ inputs.stack }}/${{ inputs.service-path }}/terraform.tfstate" \
            -backend-config="region=eu-west-3"

          echo "--- Applying Terraform for Service ---"
          cp ../environments/common.tfvars .
          cp ../environments/${{ inputs.environment }}.tfvars .
          terraform apply -auto-approve -no-color -var="stack=${{ inputs.stack }}" -var-file=common.tfvars -var-file=${{ inputs.environment }}.tfvars

      - name: Terraform Apply (Global Infra)
        if: inputs.action == 'apply' && inputs.environment == 'global'
        working-directory: ${{ inputs.service-path }}/terraform
        run: |
          echo "--- Initializing Terraform for Global Infra Apply ---"
          terraform init \
            -backend-config="bucket=sally-terraform-state-bucket" \
            -backend-config="key=${{ inputs.stack }}/${{ inputs.service-path }}/terraform.tfstate" \
            -backend-config="region=eu-west-3"

          echo "--- Applying Terraform for Global Infra ---"
          terraform apply -auto-approve -no-color -var="stack=${{ inputs.stack }}"

      - name: Terraform Destroy
        if: inputs.action == 'destroy'
        working-directory: ${{ inputs.service-path }}/terraform
        run: |
          echo "--- Initializing Terraform for Destroy ---"
          terraform init \
            -backend-config="bucket=sally-terraform-state-bucket" \
            -backend-config="key=${{ inputs.stack }}/${{ inputs.service-path }}/terraform.tfstate" \
            -backend-config="region=eu-west-3"

          echo "--- Destroying Terraform ---"
          TF_VARS=""
          if [ "${{ inputs.environment }}" != "global" ]; then
            cp ../../../environments/common.tfvars .
            cp ../../../environments/${{ inputs.environment }}.tfvars .
            TF_VARS="-var-file=common.tfvars -var-file=${{ inputs.environment }}.tfvars"
          fi
          terraform destroy -auto-approve -no-color -var="stack=${{ inputs.stack }}" ${TF_VARS}
